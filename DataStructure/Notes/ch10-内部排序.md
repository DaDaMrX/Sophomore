# Ch10 Internal Sorting

* ## Summary
    插入排序 选择排序 冒泡排序  
    快速排序 堆排序 归并排序  
    基数排序  

* ## 直接插入排序
    将整个序列分为前半部分的有序部分和后半部分的无序部分，每次选择有序部分的第一个数据插入到有序部分的恰当位置。

    O(n^2) 稳定

* ## 折半插入排序
    因为有序部分的数据是有序的，故用折半查找确定新元素的位置，从而减少比较次数，但不会减少移动次数。

    O(n^2) 稳定

* ## 希尔排序
    在待排序数据基本有序时，插入排序的效率可以大大提高。

    先对待排序记录先作“宏观”调整，使其基本有序，再进行“微观”调整，最终使其完全有序。

    不断减小子序列间隔d，直到d=1对整个序列进行直接插入排序。

    要求增量必须两两互素且最后一个增量必须为1。

    O(?) 不稳定

* ## 冒泡排序
    可以从左向右冒也可以从右向左冒，课件上为从左向右冒。

    O(n^2) 稳定

* ## 选择排序
    每次从无序序列中选择最小的数据添加到有序序列的末尾。

    O(n^2) 稳定

* ## 快速排序
    每次选取一个枢轴量（pivot），比枢轴量小的放到左边，大的放到右边，再对左右两边分别进行快速排序。

    平均时间复杂度O(nlogn)，最坏时间复杂度O(n^2)，但快速排序是所有时间排序算法中时间常数最小的。

    若每次选取第一个元素作为枢轴量，当待排序序列基本有序或者基本逆序有序时，时间复杂度退化到O(n^2)，
    为此，可以每次随机选择序列中的某个元素作为枢轴量进行快速排序。

    O(nlogn) 不稳定

* ## 堆排序
    堆是一种完全无序的完全二叉树，满足所有分支节点的数据都小于等于左右子节点的数据。

    堆根节点的数据即为所有数据中的最小值。

    堆是一种完全二叉树，故选用数组存储。

    堆支持4种基本操作：1.初始化一个空堆 2.将新元素插入堆中并调整push(x) 
    3.访问堆顶最小元素 4.删除堆顶最小元素

    两种递归的内部调整操作：1.向上调整up(i) 2.向下调整down(i)

    堆排序过程 1.封装后的操作：初始化一个空堆，依次将待排序数据放入堆中，依次取出剩余数据中的最小值

    2.PPT中给出的不封装的操作，适用于大文件：一次读入所有数据，从第n/2个元素到第1个元素，每个元素向下调整。

    O(nlogn) 不稳定

* ## 锦标赛排序
    每次选则相邻连个数据中的较小者晋级到上一层。

    从根节点选出最小值后，将这个数据替换为无穷，更新整棵树。

    可以每个分支节点都记录数据下标。

* ## 归并排序
    递归实现还是非递归实现？非递归如何实现？

    O(nlogn) 稳定

* ## 基数排序
    把一个关键词拆分为多个关键词。

    排序顺序有高位优先和低位优先，但为最终实现整体有序，选择从低级关键字开始。

    对底级关键字的排序相当于预处理，当最后对第一关键字进行基数排序时，落入同一关键字区域的数据已经是有序的了。

    设共有n个待排序记录，每个记录有k个关键字，每个关键字有r中不同的取值，则最终的时间复杂度为O(k*(n+r))  
    有k个关键词需要进行k遍基数排序，每次排序，扫描n个记录O(n)，然后首尾相接O(r)，故最终O(k*(n+r))

    O(k*(n+r)) 稳定

* ## Notice
    有大范围跨越交换的排序算法一般不稳定，比如希尔排序，快速排序，堆排序。
